{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///external_api.min.js","webpack:///webpack/bootstrap 8289198dc07be7793894","webpack:///./modules/API/external/external_api.js","webpack:///./~/jitsi-meet-logger/lib/Logger.js","webpack:///./~/jitsi-meet-logger/lib/LogCollector.js","webpack:///./~/jitsi-meet-logger/lib/index.js","webpack:///./~/postis/src/index.js"],"names":["root","factory","exports","module","define","amd","JitsiMeetExternalAPI","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__filename","sendMessage","postis","object","send","changeEventStatus","event","status","events","method","params","type","name","value","logger","error","domain","room_name","width","height","parentNode","configOverwrite","interfaceConfigOverwrite","noSsl","MIN_WIDTH","MIN_HEIGHT","scriptTag","document","scripts","length","iframeHolder","appendChild","createElement","style","frameName","url","key","hasOwnProperty","frame","src","setAttribute","postisInit","window","contentWindow","scope","eventHandlers","getLogger","commands","displayName","toggleAudio","toggleVideo","toggleFilmStrip","toggleChat","toggleContactList","toggleShareScreen","hangup","participantKicked","incomingMessage","outgoingMessage","displayNameChange","participantJoined","participantLeft","videoConferenceJoined","videoConferenceLeft","readyToClose","prototype","executeCommand","argumentsList","argumentsArray","executeCommands","addEventListeners","i","addEventListener","listener","listen","data","bind","removeEventListener","removeEventListeners","dispose","destroy","getElementById","self","setTimeout","removeChild","getCallerInfo","callerInfo","methodName","fileLocation","line","column","Error","stack","split","match","indexOf","substr","log","arguments","level","args","Array","slice","levels","transports","globalTransports","concat","t","l","u","apply","Logger","format","methods","Object","keys","trace","debug","info","warn","consoleTransport","console","addGlobalTransport","transport","push","removeGlobalTransport","transportIdx","splice","setLevel","TRACE","DEBUG","INFO","LOG","WARN","ERROR","LogCollector","logStorage","options","stringifyObjects","storeInterval","maxEntryLength","forEach","logLevel","_log","storeLogsIntervalID","queue","totalLen","outputCache","stringify","someObject","JSON","formatLogMessage","msg","len","arg","prevMessage","undefined","prevMessageText","text","count","_flush","start","_reschedulePublishInterval","clearTimeout","flush","force","reschedule","isReady","cachedQueue","storeLogs","stop","idLoggers","loggers","curLevel","setLogLevelById","setLogLevel","Postis","readynessCheck","targetWindow","windowForEventListening","listeners","sendBuffer","listenBuffer","ready","readyMethod","parse","e","listenersForMethod","callback","listenBufferForMethod","j","opts","postMessage","clearInterval","readyCheckID","Date","Math","random","setInterval"],"mappings":"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","file":"external_api.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JitsiMeetExternalAPI\"] = factory();\n\telse\n\t\troot[\"JitsiMeetExternalAPI\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JitsiMeetExternalAPI\"] = factory();\n\telse\n\t\troot[\"JitsiMeetExternalAPI\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/libs/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {\"use strict\";\n\t\n\tvar logger = __webpack_require__(3).getLogger(__filename);\n\t\n\t/**\n\t * Implements API class that embeds Jitsi Meet in external applications.\n\t */\n\t\n\tvar postisInit = __webpack_require__(4);\n\t\n\t/**\n\t * The minimum width for the Jitsi Meet frame\n\t * @type {number}\n\t */\n\tvar MIN_WIDTH = 790;\n\t\n\t/**\n\t * The minimum height for the Jitsi Meet frame\n\t * @type {number}\n\t */\n\tvar MIN_HEIGHT = 300;\n\t\n\t/**\n\t * Last id of api object\n\t * @type {number}\n\t */\n\tvar id = 0;\n\t\n\t/**\n\t * Maps the names of the commands expected by the API with the name of the\n\t * commands expected by jitsi-meet\n\t */\n\tvar commands = {\n\t    \"displayName\": \"display-name\",\n\t    \"toggleAudio\": \"toggle-audio\",\n\t    \"toggleVideo\": \"toggle-video\",\n\t    \"toggleFilmStrip\": \"toggle-film-strip\",\n\t    \"toggleChat\": \"toggle-chat\",\n\t    \"toggleContactList\": \"toggle-contact-list\",\n\t    \"toggleShareScreen\": \"toggle-share-screen\",\n\t    \"hangup\": \"video-hangup\"\n\t};\n\t\n\t/**\n\t * Maps the names of the events expected by the API with the name of the\n\t * events expected by jitsi-meet\n\t */\n\tvar events = {\n\t    \"participantKicked\": \"participant-kicked\",\n\t    \"incomingMessage\": \"incoming-message\",\n\t    \"outgoingMessage\": \"outgoing-message\",\n\t    \"displayNameChange\": \"display-name-change\",\n\t    \"participantJoined\": \"participant-joined\",\n\t    \"participantLeft\": \"participant-left\",\n\t    \"videoConferenceJoined\": \"video-conference-joined\",\n\t    \"videoConferenceLeft\": \"video-conference-left\",\n\t    \"readyToClose\": \"video-ready-to-close\"\n\t};\n\t\n\t/**\n\t * Sends the passed object to Jitsi Meet\n\t * @param postis {Postis object} the postis instance that is going to be used\n\t * to send the message\n\t * @param object the object to be sent\n\t * - method {sting}\n\t * - params {object}\n\t */\n\tfunction sendMessage(postis, object) {\n\t    postis.send(object);\n\t}\n\t\n\t/**\n\t * Sends message for event enable/disable status change.\n\t * @param postis {Postis object} the postis instance that is going to be used.\n\t * @param event {string} the name of the event\n\t * @param status {boolean} true - enabled; false - disabled;\n\t */\n\tfunction changeEventStatus(postis, event, status) {\n\t    if (!(event in events)) {\n\t        logger.error(\"Not supported event name.\");\n\t        return;\n\t    }\n\t    sendMessage(postis, {\n\t        method: \"jitsiSystemMessage\",\n\t        params: { type: \"eventStatus\", name: events[event], value: status }\n\t    });\n\t}\n\t\n\t/**\n\t * Constructs new API instance. Creates iframe element that loads\n\t * Jitsi Meet.\n\t * @param domain the domain name of the server that hosts the conference\n\t * @param room_name the name of the room to join\n\t * @param width width of the iframe\n\t * @param height height of the iframe\n\t * @param parent_node the node that will contain the iframe\n\t * @param filmStripOnly if the value is true only the small videos will be\n\t * visible.\n\t * @param noSsl if the value is true https won't be used\n\t * @constructor\n\t */\n\tfunction JitsiMeetExternalAPI(domain, room_name, width, height, parentNode, configOverwrite, interfaceConfigOverwrite, noSsl) {\n\t    if (!width || width < MIN_WIDTH) width = MIN_WIDTH;\n\t    if (!height || height < MIN_HEIGHT) height = MIN_HEIGHT;\n\t\n\t    this.parentNode = null;\n\t    if (parentNode) {\n\t        this.parentNode = parentNode;\n\t    } else {\n\t        var scriptTag = document.scripts[document.scripts.length - 1];\n\t        this.parentNode = scriptTag.parentNode;\n\t    }\n\t\n\t    this.iframeHolder = this.parentNode.appendChild(document.createElement(\"div\"));\n\t    this.iframeHolder.id = \"jitsiConference\" + id;\n\t    if (width) this.iframeHolder.style.width = width + \"px\";\n\t    if (height) this.iframeHolder.style.height = height + \"px\";\n\t    this.frameName = \"jitsiConferenceFrame\" + id;\n\t    this.url = noSsl ? \"http\" : \"https\" + \"://\" + domain + \"/\";\n\t    if (room_name) this.url += room_name;\n\t    this.url += \"#jitsi_meet_external_api_id=\" + id;\n\t\n\t    var key;\n\t    if (configOverwrite) {\n\t        for (key in configOverwrite) {\n\t            if (!configOverwrite.hasOwnProperty(key) || typeof key !== 'string') continue;\n\t            this.url += \"&config.\" + key + \"=\" + configOverwrite[key];\n\t        }\n\t    }\n\t\n\t    if (interfaceConfigOverwrite) {\n\t        for (key in interfaceConfigOverwrite) {\n\t            if (!interfaceConfigOverwrite.hasOwnProperty(key) || typeof key !== 'string') continue;\n\t            this.url += \"&interfaceConfig.\" + key + \"=\" + interfaceConfigOverwrite[key];\n\t        }\n\t    }\n\t\n\t    this.frame = document.createElement(\"iframe\");\n\t    this.frame.src = this.url;\n\t    this.frame.name = this.frameName;\n\t    this.frame.id = this.frameName;\n\t    this.frame.width = \"100%\";\n\t    this.frame.height = \"100%\";\n\t    this.frame.setAttribute(\"allowFullScreen\", \"true\");\n\t    this.frame = this.iframeHolder.appendChild(this.frame);\n\t    this.postis = postisInit({\n\t        window: this.frame.contentWindow,\n\t        scope: \"jitsi_meet_external_api_\" + id\n\t    });\n\t\n\t    this.eventHandlers = {};\n\t\n\t    id++;\n\t}\n\t\n\t/**\n\t * Executes command. The available commands are:\n\t * displayName - sets the display name of the local participant to the value\n\t * passed in the arguments array.\n\t * toggleAudio - mutes / unmutes audio with no arguments\n\t * toggleVideo - mutes / unmutes video with no arguments\n\t * filmStrip - hides / shows the film strip with no arguments\n\t * If the command doesn't require any arguments the parameter should be set\n\t * to empty array or it may be omitted.\n\t * @param name the name of the command\n\t * @param arguments array of arguments\n\t */\n\tJitsiMeetExternalAPI.prototype.executeCommand = function (name, argumentsList) {\n\t    if (!(name in commands)) {\n\t        logger.error(\"Not supported command name.\");\n\t        return;\n\t    }\n\t    var argumentsArray = argumentsList;\n\t    if (!argumentsArray) argumentsArray = [];\n\t    sendMessage(this.postis, { method: commands[name], params: argumentsArray });\n\t};\n\t\n\t/**\n\t * Executes commands. The available commands are:\n\t * displayName - sets the display name of the local participant to the value\n\t * passed in the arguments array.\n\t * toggleAudio - mutes / unmutes audio. no arguments\n\t * toggleVideo - mutes / unmutes video. no arguments\n\t * filmStrip - hides / shows the film strip. no arguments\n\t * toggleChat - hides / shows chat. no arguments.\n\t * toggleContactList - hides / shows contact list. no arguments.\n\t * toggleShareScreen - starts / stops screen sharing. no arguments.\n\t * @param object the object with commands to be executed. The keys of the\n\t * object are the commands that will be executed and the values are the\n\t * arguments for the command.\n\t */\n\tJitsiMeetExternalAPI.prototype.executeCommands = function (object) {\n\t    for (var key in object) {\n\t        this.executeCommand(key, object[key]);\n\t    }\n\t};\n\t\n\t/**\n\t * Adds event listeners to Meet Jitsi. The object key should be the name of\n\t * the event and value - the listener.\n\t * Currently we support the following\n\t * events:\n\t * incomingMessage - receives event notifications about incoming\n\t * messages. The listener will receive object with the following structure:\n\t * {{\n\t *  \"from\": from,//JID of the user that sent the message\n\t *  \"nick\": nick,//the nickname of the user that sent the message\n\t *  \"message\": txt//the text of the message\n\t * }}\n\t * outgoingMessage - receives event notifications about outgoing\n\t * messages. The listener will receive object with the following structure:\n\t * {{\n\t *  \"message\": txt//the text of the message\n\t * }}\n\t * displayNameChanged - receives event notifications about display name\n\t * change. The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid,//the JID of the participant that changed his display name\n\t * displayname: displayName //the new display name\n\t * }}\n\t * participantJoined - receives event notifications about new participant.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid //the jid of the participant\n\t * }}\n\t * participantLeft - receives event notifications about the participant that\n\t * left the room.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid //the jid of the participant\n\t * }}\n\t * video-conference-joined - receives event notifications about the local user\n\t * has successfully joined the video conference.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * roomName: room //the room name of the conference\n\t * }}\n\t * video-conference-left - receives event notifications about the local user\n\t * has left the video conference.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * roomName: room //the room name of the conference\n\t * }}\n\t * readyToClose - all hangup operations are completed and Jitsi Meet is ready\n\t * to be disposed.\n\t * @param object\n\t */\n\tJitsiMeetExternalAPI.prototype.addEventListeners = function (object) {\n\t    for (var i in object) {\n\t        this.addEventListener(i, object[i]);\n\t    }\n\t};\n\t\n\t/**\n\t * Adds event listeners to Meet Jitsi. Currently we support the following\n\t * events:\n\t * incomingMessage - receives event notifications about incoming\n\t * messages. The listener will receive object with the following structure:\n\t * {{\n\t *  \"from\": from,//JID of the user that sent the message\n\t *  \"nick\": nick,//the nickname of the user that sent the message\n\t *  \"message\": txt//the text of the message\n\t * }}\n\t * outgoingMessage - receives event notifications about outgoing\n\t * messages. The listener will receive object with the following structure:\n\t * {{\n\t *  \"message\": txt//the text of the message\n\t * }}\n\t * displayNameChanged - receives event notifications about display name\n\t * change. The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid,//the JID of the participant that changed his display name\n\t * displayname: displayName //the new display name\n\t * }}\n\t * participantJoined - receives event notifications about new participant.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid //the jid of the participant\n\t * }}\n\t * participantLeft - receives event notifications about participant the that\n\t * left the room.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * jid: jid //the jid of the participant\n\t * }}\n\t * video-conference-joined - receives event notifications fired when the local\n\t * user has joined the video conference.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * roomName: room //the room name of the conference\n\t * }}\n\t * video-conference-left - receives event notifications fired when the local\n\t * user has joined the video conference.\n\t * The listener will receive object with the following structure:\n\t * {{\n\t * roomName: room //the room name of the conference\n\t * }}\n\t * @param event the name of the event\n\t * @param listener the listener\n\t */\n\tJitsiMeetExternalAPI.prototype.addEventListener = function (event, listener) {\n\t    if (!(event in events)) {\n\t        logger.error(\"Not supported event name.\");\n\t        return;\n\t    }\n\t    // We cannot remove listeners from postis that's why we are handling the\n\t    // callback that way.\n\t    if (!(event in this.eventHandlers)) this.postis.listen(events[event], function (data) {\n\t        if (event in this.eventHandlers && typeof this.eventHandlers[event] === \"function\") this.eventHandlers[event].call(null, data);\n\t    }.bind(this));\n\t    this.eventHandlers[event] = listener;\n\t    changeEventStatus(this.postis, event, true);\n\t};\n\t\n\t/**\n\t * Removes event listener.\n\t * @param event the name of the event.\n\t */\n\tJitsiMeetExternalAPI.prototype.removeEventListener = function (event) {\n\t    if (!(event in this.eventHandlers)) {\n\t        logger.error(\"The event \" + event + \" is not registered.\");\n\t        return;\n\t    }\n\t    delete this.eventHandlers[event];\n\t    changeEventStatus(this.postis, event, false);\n\t};\n\t\n\t/**\n\t * Removes event listeners.\n\t * @param events array with the names of the events.\n\t */\n\tJitsiMeetExternalAPI.prototype.removeEventListeners = function (events) {\n\t    for (var i = 0; i < events.length; i++) {\n\t        this.removeEventListener(events[i]);\n\t    }\n\t};\n\t\n\t/**\n\t * Removes the listeners and removes the Jitsi Meet frame.\n\t */\n\tJitsiMeetExternalAPI.prototype.dispose = function () {\n\t    this.postis.destroy();\n\t    var frame = document.getElementById(this.frameName);\n\t    if (frame) frame.src = 'about:blank';\n\t    var self = this;\n\t    window.setTimeout(function () {\n\t        self.iframeHolder.removeChild(self.frame);\n\t        self.iframeHolder.parentNode.removeChild(self.iframeHolder);\n\t    }, 10);\n\t};\n\t\n\tmodule.exports = JitsiMeetExternalAPI;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/API/external/external_api.js\"))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * Ordered log levels.\n\t */\n\tvar levels = {\n\t    \"trace\": 0,\n\t    \"debug\": 1,\n\t    \"info\": 2,\n\t    \"log\": 3,\n\t    \"warn\": 4,\n\t    \"error\": 5\n\t};\n\t\n\t/**\n\t * The default transport - console\n\t * @type LoggerTransport\n\t */\n\tLogger.consoleTransport = console;\n\t\n\t/**\n\t * The array which stores currently registered global transports.\n\t * @type {[LoggerTransport]}\n\t */\n\tvar globalTransports = [ Logger.consoleTransport ];\n\t\n\t/**\n\t * Adds given {@link LoggerTransport} instance to the list of global\n\t * transports which means that it'll be used by all {@link Logger}s\n\t * @param {LoggerTransport} transport\n\t */\n\tLogger.addGlobalTransport = function(transport) {\n\t    if (globalTransports.indexOf(transport) === -1) {\n\t        globalTransports.push(transport);\n\t    }\n\t};\n\t\n\t/**\n\t * Removes given {@link LoggerTransport} instance from the list of global\n\t * transports\n\t * @param {LoggerTransport} transport\n\t */\n\tLogger.removeGlobalTransport = function(transport) {\n\t    var transportIdx = globalTransports.indexOf(transport);\n\t    if (transportIdx !== -1) {\n\t        globalTransports.splice(transportIdx, 1);\n\t    }\n\t};\n\t\n\t/**\n\t * Parses Error's object stack trace and extracts information about the last\n\t * caller before the log method was called.\n\t * @returns JS object with info about the caller - method name, file location,\n\t * line and column.\n\t */\n\tfunction getCallerInfo() {\n\t    var callerInfo = {\n\t        methodName: \"\",\n\t        fileLocation: \"\",\n\t        line: null,\n\t        column: null\n\t    };\n\t    //gets the part of the stack without the logger wrappers\n\t    var error = new Error();\n\t    var stack = error.stack? error.stack.split(\"\\n\") : [];\n\t    if(!stack || stack.length < 1) {\n\t        return callerInfo;\n\t    }\n\t    var m = null;\n\t    if(stack[3]) {\n\t        m = stack[3].match(/\\s*at\\s*(.+?)\\s*\\((\\S*)\\s*:(\\d*)\\s*:(\\d*)\\)/);\n\t    }\n\t    if(!m || m.length <= 4) {\n\t        //Firefox && Safari\n\t        if(stack[2].indexOf(\"log@\") === 0){\n\t            //Safari\n\t            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf(\"@\"));\n\t        } else {\n\t            //Firefox\n\t            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf(\"@\"));\n\t        }\n\t        return callerInfo;\n\t    }\n\t\n\t    callerInfo.methodName = m[1];\n\t    callerInfo.fileLocation = m[2];\n\t    callerInfo.line = m[3];\n\t    callerInfo.column = m[4];\n\t    return callerInfo;\n\t}\n\t\n\t/**\n\t * Logs messages using the transports and level from the logger.\n\t * @param logger a logger instance.\n\t * @param level the log level of the message. See the levels variable.\n\t * @param arguments array with arguments that will be logged.\n\t */\n\tfunction log() {\n\t    var logger = arguments[0], level = arguments[1],\n\t        args = Array.prototype.slice.call(arguments, 2);\n\t    if(levels[level] < logger.level) {\n\t        return;\n\t    }\n\t\n\t    var callerInfo = getCallerInfo();\n\t    var transports = globalTransports.concat(logger.transports);\n\t    for(var i = 0; i < transports.length; i++) {\n\t        var t = transports[i];\n\t        var l = t[level];\n\t        if(l && typeof(l) === \"function\") {\n\t            l.bind(t, logger.id? \"[\" + logger.id + \"]\" : \"\", \"<\" + callerInfo.methodName + \">: \")\n\t                .apply(t, args);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t *\n\t * Constructs new logger object.\n\t * @param level the logging level for the new logger\n\t * @param id optional identifier for the logger instance.\n\t * @param {LoggerTransport} transports optional list of handlers(objects) for\n\t * the logs. The handlers must support - log, warn, error, debug, info, trace.\n\t * @param format optional (NOT implemented) string.\n\t */\n\tfunction Logger(level, id, transports, format) {\n\t    this.id = id;\n\t    this.format = format;\n\t    this.transports = transports;\n\t    if(!this.transports) {\n\t        this.transports = [];\n\t    }\n\t    this.level = levels[level];\n\t    var methods = Object.keys(levels);\n\t    for(var i = 0; i < methods.length; i++){\n\t        this[methods[i]] =\n\t            log.bind(null, this, methods[i]);\n\t    }\n\t}\n\t\n\t/**\n\t * Sets the log level for the logger.\n\t * @param level the new log level.\n\t */\n\tLogger.prototype.setLevel = function (level) {\n\t    this.level = levels[level];\n\t};\n\tmodule.exports = Logger;\n\t\n\t/**\n\t * Enum for the supported log levels.\n\t */\n\tLogger.levels = {\n\t    TRACE: \"trace\",\n\t    DEBUG: \"debug\",\n\t    INFO: \"info\",\n\t    LOG: \"log\",\n\t    WARN: \"warn\",\n\t    ERROR: \"error\"\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2016 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\tvar Logger = __webpack_require__(1);\n\t\n\t/**\n\t * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>\n\t * and thus can be added as global transport in order to capture all the logs.\n\t *\n\t * It captures subsequent log lines created whenever <tt>Logger</tt> logs\n\t * a message and stores them in a queue in order to batch log entries. There are\n\t * time and size limit constraints which determine how often batch entries are\n\t * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>\n\t * will use the <tt>logStorage</tt> object given as an argument to save\n\t * the batch log entry.\n\t *\n\t * @param {Object} logStorage an object which allows to store the logs collected\n\t * @param {function(string|object[])} logStorage.storeLogs a method called when\n\t * this <tt>LogCollector</tt> requests log entry storage. The method's argument\n\t * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given\n\t * item is an object it means that it's an aggregated message. That is a message\n\t * which is the same as the previous one and it's representation has\n\t * the following format:\n\t * {\n\t *   {string} text: 'the text of some duplicated message'\n\t *   {number} count: 3 // how many times the message appeared in a row\n\t * }\n\t * If a message \"B\" after an aggregated message \"A\" is different, then it breaks\n\t * the sequence of \"A\". Which means that even if the next message \"C\" is\n\t * the same as \"A\" it will start a new aggregated message \"C\".\n\t * @param {function()} logStorage.isReady a method which should return\n\t * a <tt>boolean</tt> to tell the collector that it's ready to store. During the\n\t * time storage is not ready log batches will be cached and stored on the next\n\t * occasion (flush or interval timeout).\n\t *\n\t * @param {Object} options the <tt>LogCollector</tt> configuration options.\n\t * @param {number} options.maxEntryLength the size limit for a single log entry\n\t * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it\n\t * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>\n\t * returns <tt>true</tt>. Otherwise the log entry will be cached until the log\n\t * storage becomes ready. Note that the \"is ready\" condition is checked every\n\t * <tt>options.storeInterval</tt> milliseconds.\n\t * @param {number} options.storeInterval how often the logs should be stored in\n\t * case <tt>maxEntryLength</tt> was not exceeded.\n\t * @param {boolean} options.stringifyObjects indicates whether or not object\n\t * arguments should be \"stringified\" with <tt>JSON.stringify</tt> when a log\n\t * message is composed. Note that objects logged on the error log level are\n\t * always stringified.\n\t *\n\t * @constructor\n\t */\n\tfunction LogCollector(logStorage, options) {\n\t    this.logStorage = logStorage;\n\t    this.stringifyObjects\n\t        = options && options.stringifyObjects\n\t            ? options.stringifyObjects : false;\n\t    this.storeInterval\n\t        = options && options.storeInterval\n\t            ? options.storeInterval: 30000;\n\t    this.maxEntryLength\n\t        = options && options.maxEntryLength\n\t            ? options.maxEntryLength : 10000;\n\t    // Bind the log method for each level to the corresponding method name\n\t    // in order to implement \"global log transport\" object.\n\t    Object.keys(Logger.levels).forEach(\n\t    function (logLevel) {\n\t        var methodName = Logger.levels[logLevel];\n\t        this[methodName] = function (logLevel) {\n\t            this._log.apply(this, arguments);\n\t        }.bind(this, logLevel);\n\t    }.bind(this));\n\t    /**\n\t     * The ID of store logs interval if one is currently scheduled or\n\t     * <tt>null</tt> otherwise.\n\t     * @type {number|null}\n\t     */\n\t    this.storeLogsIntervalID = null;\n\t    /**\n\t     * The log messages that are to be batched into log entry when\n\t     * {@link LogCollector._flush} method is called.\n\t     * @type {string[]}\n\t     */\n\t    this.queue = [];\n\t    /**\n\t     * The total length of all messages currently stored in the {@link queue}.\n\t     * @type {number}\n\t     */\n\t    this.totalLen = 0;\n\t    /**\n\t     * An array used to temporarily store log batches, before the storage gets\n\t     * ready.\n\t     * @type {string[]}\n\t     */\n\t    this.outputCache = [];\n\t}\n\t\n\t/**\n\t * Method called inside of {@link formatLogMessage} in order to covert an\n\t * <tt>Object</tt> argument to string. The conversion will happen when either\n\t * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}\n\t * log level. The default implementation uses <tt>JSON.stringify</tt> and\n\t * returns \"[object with circular refs?]\" instead of an object if it fails.\n\t *\n\t * @param {object} someObject the <tt>object</tt> to be stringified.\n\t *\n\t * @return {string} the result of <tt>JSON.stringify</tt> or\n\t * \"[object with circular refs?]\" if any error occurs during \"stringification\".\n\t *\n\t * @protected\n\t */\n\tLogCollector.prototype.stringify = function (someObject) {\n\t    try {\n\t        return JSON.stringify(someObject);\n\t    } catch (error) {\n\t        return \"[object with circular refs?]\";\n\t    }\n\t};\n\t\n\t/**\n\t * Formats log entry for the given logging level and arguments passed to the\n\t * <tt>Logger</tt>'s log method. The first argument is log level and the next\n\t * arguments have to be captured using JS built-in 'arguments' variable.\n\t *\n\t * @param {Logger.levels} logLevel provides the logging level of the message to\n\t * be logged.\n\t *\n\t * @return {string|null} a non-empty string representation of the log entry\n\t * crafted from the log arguments. If the return value is <tt>null</tt> then\n\t * the message wil be discarded by this <tt>LogCollector</tt>.\n\t *\n\t * @protected\n\t */\n\tLogCollector.prototype.formatLogMessage\n\t= function (logLevel/*, arg1, arg2, arg3... */) {\n\t    var msg = '';\n\t    for (var i = 1, len = arguments.length; i < len; i++) {\n\t        var arg = arguments[i];\n\t        // objects logged on error level are always converted to JSON\n\t        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR)\n\t            && typeof arg === 'object') {\n\t            arg = this.stringify(arg);\n\t        }\n\t        msg += arg;\n\t        if (i != len - 1) {\n\t            msg += ' ';\n\t        }\n\t    }\n\t    return msg.length ? msg : null;\n\t};\n\t\n\t/**\n\t * The log method bound to each of the logging levels in order to implement\n\t * \"global log transport\" object.\n\t *\n\t * @private\n\t */\n\tLogCollector.prototype._log = function() {\n\t\n\t    // var logLevel = arguments[0]; first argument is the log level\n\t    var msg = this.formatLogMessage.apply(this, arguments);\n\t    if (msg) {\n\t        // The same as the previous message aggregation logic\n\t        var prevMessage\n\t            = this.queue.length ? this.queue[this.queue.length -1] : undefined;\n\t        // NOTE that typeof undefined is 'undefined'\n\t        var prevMessageText\n\t            = typeof prevMessage === 'object' ? prevMessage.text : prevMessage;\n\t        // Is it the same as the previous one ?\n\t        if (prevMessageText == msg) {\n\t            if (typeof prevMessage === 'object') {\n\t                prevMessage.count += 1;\n\t            } else {\n\t                this.queue[this.queue.length-1] = {\n\t                    text: msg,\n\t                    count: 2\n\t                }\n\t            }\n\t        } else {\n\t            this.queue.push(msg);\n\t            this.totalLen += msg.length;\n\t        }\n\t    }\n\t\n\t    if (this.totalLen >= this.maxEntryLength) {\n\t        this._flush(true /* force */, true /* reschedule */);\n\t    }\n\t};\n\t\n\t/**\n\t * Starts periodical \"store logs\" task which will be triggered at the interval\n\t * specified in the constructor options.\n\t */\n\tLogCollector.prototype.start = function () {\n\t    this._reschedulePublishInterval();\n\t};\n\t\n\t/**\n\t * Reschedules the periodical \"store logs\" task which will store the next batch\n\t * log entry in the storage.\n\t * @private\n\t */\n\tLogCollector.prototype._reschedulePublishInterval = function () {\n\t    if (this.storeLogsIntervalID) {\n\t        window.clearTimeout(this.storeLogsIntervalID);\n\t        this.storeLogsIntervalID = null;\n\t    }\n\t    // It's actually a timeout, because it is rescheduled on every flush\n\t    this.storeLogsIntervalID\n\t        = window.setTimeout(\n\t            this._flush.bind(\n\t                this, false /* do not force */, true /* reschedule */),\n\t            this.storeInterval);\n\t};\n\t\n\t/**\n\t * Call this method to flush the log entry buffer and store it in the log\n\t * storage immediately (given that the storage is ready).\n\t */\n\tLogCollector.prototype.flush = function() {\n\t    this._flush(\n\t        false /* do not force, as it will not be stored anyway */,\n\t        true /* reschedule next update */ )\n\t};\n\t\n\t/**\n\t * Stores the next batch log entry in the log storage.\n\t * @param {boolean} force enforce current logs batch to be stored or cached if\n\t * there is anything to be logged, but the storage is not ready yet. One of\n\t * legitimate reasons to force is when the logs length exceeds size limit which\n\t * could result in truncation.\n\t * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be\n\t * scheduled after the log entry is stored. <tt>false</tt> will end the periodic\n\t * task cycle.\n\t * @private\n\t */\n\tLogCollector.prototype._flush = function(force, reschedule) {\n\t    // Publish only if there's anything to be logged\n\t    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {\n\t        //FIXME avoid truncating\n\t        // right now we don't care if the message size is \"slightly\" exceeded\n\t        if (this.logStorage.isReady()) {\n\t            // Sends all cached logs\n\t            if (this.outputCache.length) {\n\t                this.outputCache.forEach(\n\t                    function (cachedQueue) {\n\t                        this.logStorage.storeLogs(cachedQueue);\n\t                    }.bind(this)\n\t                );\n\t                // Clear the cache\n\t                this.outputCache = [];\n\t            }\n\t            // Send current batch\n\t            this.logStorage.storeLogs(this.queue);\n\t        } else {\n\t            this.outputCache.push(this.queue);\n\t        }\n\t\n\t        this.queue = [];\n\t        this.totalLen = 0;\n\t    }\n\t\n\t    if (reschedule) {\n\t        this._reschedulePublishInterval();\n\t    }\n\t};\n\t\n\t/**\n\t * Stops the periodical \"store logs\" task and immediately stores any pending\n\t * log entries as a batch.\n\t */\n\tLogCollector.prototype.stop = function() {\n\t    // Flush and stop publishing logs\n\t    this._flush(false /* do not force */, false /* do not reschedule */);\n\t};\n\t\n\tmodule.exports = LogCollector;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\tvar Logger = __webpack_require__(1);\n\tvar LogCollector = __webpack_require__(2);\n\t\n\t/**\n\t * Definition of the log method\n\t * @name log_method\n\t * @function\n\t * @param {...*} log_args the arguments to be logged\n\t */\n\t/**\n\t * The logger's transport type definition.\n\t *\n\t * @typedef {object} LoggerTransport\n\t *\n\t * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level\n\t * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level\n\t * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level\n\t * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level\n\t * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level\n\t * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level\n\t */\n\t\n\t/**\n\t * Map with the created loggers with ID.\n\t */\n\tvar idLoggers = {};\n\t\n\t/**\n\t * Array with the loggers without id.\n\t */\n\tvar loggers = [];\n\t\n\t/**\n\t * Log level for the lbrary.\n\t */\n\tvar curLevel = Logger.levels.TRACE;\n\t\n\t\n\tmodule.exports = {\n\t    /**\n\t     * Adds given {@link LoggerTransport} instance to the list of global\n\t     * transports which means that it'll be used by all {@link Logger}s\n\t     * @param {LoggerTransport} transport\n\t     */\n\t    addGlobalTransport: function(transport) {\n\t        Logger.addGlobalTransport(transport);\n\t    },\n\t    /**\n\t     * Removes given {@link LoggerTransport} instance from the list of global\n\t     * transports\n\t     * @param {LoggerTransport} transport\n\t     */\n\t    removeGlobalTransport: function(transport) {\n\t        Logger.removeGlobalTransport(transport);\n\t    },\n\t    /**\n\t     * Creates new logger.\n\t     * @arguments the same as Logger constructor\n\t     */\n\t    getLogger: function(id, transports, format) {\n\t        var logger = new Logger(curLevel, id, transports, format);\n\t        if(id) {\n\t            idLoggers[id] = idLoggers[id] || [];\n\t            idLoggers[id].push(logger);\n\t        } else {\n\t            loggers.push(logger);\n\t        }\n\t        return logger;\n\t    },\n\t    /**\n\t     * Changes the log level for the existing loggers by id.\n\t     * @param level the new log level.\n\t     * @param id if specified the level will be changed only for loggers with the\n\t     * same id. Otherwise the operation will affect all loggers that don't\n\t     * have id.\n\t     */\n\t    setLogLevelById: function(level, id) {\n\t        var l = id? (idLoggers[id] || []) : loggers;\n\t        for(var i = 0; i < l.length; i++) {\n\t            l[i].setLevel(level);\n\t        }\n\t    },\n\t    /**\n\t     * Changes the log level for all existing loggers.\n\t     * @param level the new log level.\n\t     */\n\t    setLogLevel: function (level) {\n\t        curLevel = level;\n\t        var i = 0;\n\t        for(; i < loggers.length; i++) {\n\t            loggers[i].setLevel(level);\n\t        }\n\t\n\t        for(var id in idLoggers) {\n\t            var l = idLoggers[id] || [];\n\t            for(i = 0; i < l.length; i++) {\n\t                l[i].setLevel(level);\n\t            }\n\t        }\n\t    },\n\t    /**\n\t     * The supported log levels.\n\t     */\n\t    levels: Logger.levels,\n\t    /**\n\t     * Exports the <tt>LogCollector</tt>.\n\t     */\n\t    LogCollector: LogCollector\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tfunction Postis(options) {\n\t  var scope = options.scope;\n\t  var targetWindow = options.window;\n\t  var windowForEventListening = options.windowForEventListening || window;\n\t  var listeners = {};\n\t  var sendBuffer = [];\n\t  var listenBuffer = {};\n\t  var ready = false;\n\t  var readyMethod = \"__ready__\";\n\t  var readynessCheck;\n\t\n\t  var listener = function(event) {\n\t    var data;\n\t    try {\n\t      data = JSON.parse(event.data);\n\t    } catch (e) {\n\t      return;\n\t    }\n\t\n\t    if (data.postis && data.scope === scope) {\n\t      var listenersForMethod = listeners[data.method];\n\t      if (listenersForMethod) {\n\t        for (var i = 0; i < listenersForMethod.length; i++) {\n\t          listenersForMethod[i].call(null, data.params);\n\t        }\n\t      } else {\n\t        listenBuffer[data.method] = listenBuffer[data.method] || [];\n\t        listenBuffer[data.method].push(data.params);\n\t      }\n\t    }\n\t  };\n\t\n\t  windowForEventListening.addEventListener(\"message\", listener, false);\n\t\n\t  var postis = {\n\t    listen: function (method, callback) {\n\t      listeners[method] = listeners[method] || [];\n\t      listeners[method].push(callback);\n\t\n\t      var listenBufferForMethod = listenBuffer[method];\n\t      if (listenBufferForMethod) {\n\t        var listenersForMethod = listeners[method];\n\t        for (var i = 0; i < listenersForMethod.length; i++) {\n\t          for (var j = 0; j < listenBufferForMethod.length; j++) {\n\t            listenersForMethod[i].call(null, listenBufferForMethod[j]);\n\t          }\n\t        }\n\t      }\n\t      delete listenBuffer[method];\n\t    },\n\t\n\t    send: function (opts) {\n\t      var method = opts.method;\n\t\n\t      if ((ready || opts.method === readyMethod) && (targetWindow && typeof targetWindow.postMessage === \"function\")) {\n\t        targetWindow.postMessage(JSON.stringify({\n\t          postis: true,\n\t          scope: scope,\n\t          method: method,\n\t          params: opts.params\n\t        }), \"*\");\n\t      } else {\n\t        sendBuffer.push(opts);\n\t      }\n\t    },\n\t\n\t    ready: function (callback) {\n\t      if (ready) {\n\t        callback();\n\t      } else {\n\t        setTimeout(function () { postis.ready(callback); }, 50);\n\t      }\n\t    },\n\t\n\t    destroy: function (callback) {\n\t      clearInterval(readynessCheck);\n\t      ready = false;\n\t      if (windowForEventListening && typeof windowForEventListening.removeEventListener === \"function\") {\n\t        windowForEventListening.removeEventListener(\"message\", listener);\n\t      }\n\t      callback && callback();\n\t    }\n\t  };\n\t\n\t  var readyCheckID = +new Date() + Math.random() + \"\";\n\t\n\t  readynessCheck = setInterval(function () {\n\t    postis.send({\n\t      method: readyMethod,\n\t      params: readyCheckID\n\t    });\n\t  }, 50);\n\t\n\t  postis.listen(readyMethod, function (id) {\n\t    if (id === readyCheckID) {\n\t      clearInterval(readynessCheck);\n\t      ready = true;\n\t\n\t      for (var i = 0; i < sendBuffer.length; i++) {\n\t        postis.send(sendBuffer[i]);\n\t      }\n\t      sendBuffer = [];\n\t    } else {\n\t      postis.send({\n\t        method: readyMethod,\n\t        params: id\n\t      });\n\t    }\n\t  });\n\t\n\t  return postis;\n\t}\n\t\n\tmodule.exports = Postis;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// external_api.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/libs/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8289198dc07be7793894","const logger = require(\"jitsi-meet-logger\").getLogger(__filename);\n\n/**\n * Implements API class that embeds Jitsi Meet in external applications.\n */\n\nvar postisInit = require(\"postis\");\n\n/**\n * The minimum width for the Jitsi Meet frame\n * @type {number}\n */\nvar MIN_WIDTH = 790;\n\n/**\n * The minimum height for the Jitsi Meet frame\n * @type {number}\n */\nvar MIN_HEIGHT = 300;\n\n/**\n * Last id of api object\n * @type {number}\n */\nvar id = 0;\n\n/**\n * Maps the names of the commands expected by the API with the name of the\n * commands expected by jitsi-meet\n */\nvar commands = {\n    \"displayName\": \"display-name\",\n    \"toggleAudio\": \"toggle-audio\",\n    \"toggleVideo\": \"toggle-video\",\n    \"toggleFilmStrip\": \"toggle-film-strip\",\n    \"toggleChat\": \"toggle-chat\",\n    \"toggleContactList\": \"toggle-contact-list\",\n    \"toggleShareScreen\": \"toggle-share-screen\",\n    \"hangup\": \"video-hangup\"\n};\n\n/**\n * Maps the names of the events expected by the API with the name of the\n * events expected by jitsi-meet\n */\nvar events = {\n    \"participantKicked\": \"participant-kicked\",\n    \"incomingMessage\": \"incoming-message\",\n    \"outgoingMessage\": \"outgoing-message\",\n    \"displayNameChange\": \"display-name-change\",\n    \"participantJoined\": \"participant-joined\",\n    \"participantLeft\": \"participant-left\",\n    \"videoConferenceJoined\": \"video-conference-joined\",\n    \"videoConferenceLeft\": \"video-conference-left\",\n    \"readyToClose\": \"video-ready-to-close\"\n};\n\n/**\n * Sends the passed object to Jitsi Meet\n * @param postis {Postis object} the postis instance that is going to be used\n * to send the message\n * @param object the object to be sent\n * - method {sting}\n * - params {object}\n */\nfunction sendMessage(postis, object) {\n    postis.send(object);\n}\n\n/**\n * Sends message for event enable/disable status change.\n * @param postis {Postis object} the postis instance that is going to be used.\n * @param event {string} the name of the event\n * @param status {boolean} true - enabled; false - disabled;\n */\nfunction changeEventStatus(postis, event, status) {\n    if(!(event in events)) {\n        logger.error(\"Not supported event name.\");\n        return;\n    }\n    sendMessage(postis, {\n        method: \"jitsiSystemMessage\",\n        params: {type: \"eventStatus\", name: events[event], value: status}\n    });\n}\n\n/**\n * Constructs new API instance. Creates iframe element that loads\n * Jitsi Meet.\n * @param domain the domain name of the server that hosts the conference\n * @param room_name the name of the room to join\n * @param width width of the iframe\n * @param height height of the iframe\n * @param parent_node the node that will contain the iframe\n * @param filmStripOnly if the value is true only the small videos will be\n * visible.\n * @param noSsl if the value is true https won't be used\n * @constructor\n */\nfunction JitsiMeetExternalAPI(domain, room_name, width, height, parentNode,\n    configOverwrite, interfaceConfigOverwrite, noSsl) {\n    if (!width || width < MIN_WIDTH)\n        width = MIN_WIDTH;\n    if (!height || height < MIN_HEIGHT)\n        height = MIN_HEIGHT;\n\n    this.parentNode = null;\n    if (parentNode) {\n        this.parentNode = parentNode;\n    } else {\n        var scriptTag = document.scripts[document.scripts.length - 1];\n        this.parentNode = scriptTag.parentNode;\n    }\n\n    this.iframeHolder =\n        this.parentNode.appendChild(document.createElement(\"div\"));\n    this.iframeHolder.id = \"jitsiConference\" + id;\n    if(width)\n        this.iframeHolder.style.width = width + \"px\";\n    if(height)\n        this.iframeHolder.style.height = height + \"px\";\n    this.frameName = \"jitsiConferenceFrame\" + id;\n    this.url = (noSsl) ? \"http\" : \"https\" +\"://\" + domain + \"/\";\n    if(room_name)\n        this.url += room_name;\n    this.url += \"#jitsi_meet_external_api_id=\" + id;\n\n    var key;\n    if (configOverwrite) {\n        for (key in configOverwrite) {\n            if (!configOverwrite.hasOwnProperty(key) ||\n                typeof key !== 'string')\n                continue;\n            this.url += \"&config.\" + key + \"=\" + configOverwrite[key];\n        }\n    }\n\n    if (interfaceConfigOverwrite) {\n        for (key in interfaceConfigOverwrite) {\n            if (!interfaceConfigOverwrite.hasOwnProperty(key) ||\n                typeof key !== 'string')\n                continue;\n            this.url += \"&interfaceConfig.\" + key + \"=\" +\n                interfaceConfigOverwrite[key];\n        }\n    }\n\n    this.frame = document.createElement(\"iframe\");\n    this.frame.src = this.url;\n    this.frame.name = this.frameName;\n    this.frame.id = this.frameName;\n    this.frame.width = \"100%\";\n    this.frame.height = \"100%\";\n    this.frame.setAttribute(\"allowFullScreen\",\"true\");\n    this.frame = this.iframeHolder.appendChild(this.frame);\n    this.postis = postisInit({\n        window: this.frame.contentWindow,\n        scope: \"jitsi_meet_external_api_\" + id\n    });\n\n    this.eventHandlers = {};\n\n    id++;\n}\n\n/**\n * Executes command. The available commands are:\n * displayName - sets the display name of the local participant to the value\n * passed in the arguments array.\n * toggleAudio - mutes / unmutes audio with no arguments\n * toggleVideo - mutes / unmutes video with no arguments\n * filmStrip - hides / shows the film strip with no arguments\n * If the command doesn't require any arguments the parameter should be set\n * to empty array or it may be omitted.\n * @param name the name of the command\n * @param arguments array of arguments\n */\nJitsiMeetExternalAPI.prototype.executeCommand = function(name, argumentsList) {\n    if(!(name in commands)) {\n        logger.error(\"Not supported command name.\");\n        return;\n    }\n    var argumentsArray = argumentsList;\n    if (!argumentsArray)\n        argumentsArray = [];\n    sendMessage(this.postis, {method: commands[name], params: argumentsArray});\n};\n\n/**\n * Executes commands. The available commands are:\n * displayName - sets the display name of the local participant to the value\n * passed in the arguments array.\n * toggleAudio - mutes / unmutes audio. no arguments\n * toggleVideo - mutes / unmutes video. no arguments\n * filmStrip - hides / shows the film strip. no arguments\n * toggleChat - hides / shows chat. no arguments.\n * toggleContactList - hides / shows contact list. no arguments.\n * toggleShareScreen - starts / stops screen sharing. no arguments.\n * @param object the object with commands to be executed. The keys of the\n * object are the commands that will be executed and the values are the\n * arguments for the command.\n */\nJitsiMeetExternalAPI.prototype.executeCommands = function(object) {\n    for(var key in object)\n        this.executeCommand(key, object[key]);\n};\n\n/**\n * Adds event listeners to Meet Jitsi. The object key should be the name of\n * the event and value - the listener.\n * Currently we support the following\n * events:\n * incomingMessage - receives event notifications about incoming\n * messages. The listener will receive object with the following structure:\n * {{\n *  \"from\": from,//JID of the user that sent the message\n *  \"nick\": nick,//the nickname of the user that sent the message\n *  \"message\": txt//the text of the message\n * }}\n * outgoingMessage - receives event notifications about outgoing\n * messages. The listener will receive object with the following structure:\n * {{\n *  \"message\": txt//the text of the message\n * }}\n * displayNameChanged - receives event notifications about display name\n * change. The listener will receive object with the following structure:\n * {{\n * jid: jid,//the JID of the participant that changed his display name\n * displayname: displayName //the new display name\n * }}\n * participantJoined - receives event notifications about new participant.\n * The listener will receive object with the following structure:\n * {{\n * jid: jid //the jid of the participant\n * }}\n * participantLeft - receives event notifications about the participant that\n * left the room.\n * The listener will receive object with the following structure:\n * {{\n * jid: jid //the jid of the participant\n * }}\n * video-conference-joined - receives event notifications about the local user\n * has successfully joined the video conference.\n * The listener will receive object with the following structure:\n * {{\n * roomName: room //the room name of the conference\n * }}\n * video-conference-left - receives event notifications about the local user\n * has left the video conference.\n * The listener will receive object with the following structure:\n * {{\n * roomName: room //the room name of the conference\n * }}\n * readyToClose - all hangup operations are completed and Jitsi Meet is ready\n * to be disposed.\n * @param object\n */\nJitsiMeetExternalAPI.prototype.addEventListeners = function(object) {\n    for(var i in object)\n        this.addEventListener(i, object[i]);\n};\n\n/**\n * Adds event listeners to Meet Jitsi. Currently we support the following\n * events:\n * incomingMessage - receives event notifications about incoming\n * messages. The listener will receive object with the following structure:\n * {{\n *  \"from\": from,//JID of the user that sent the message\n *  \"nick\": nick,//the nickname of the user that sent the message\n *  \"message\": txt//the text of the message\n * }}\n * outgoingMessage - receives event notifications about outgoing\n * messages. The listener will receive object with the following structure:\n * {{\n *  \"message\": txt//the text of the message\n * }}\n * displayNameChanged - receives event notifications about display name\n * change. The listener will receive object with the following structure:\n * {{\n * jid: jid,//the JID of the participant that changed his display name\n * displayname: displayName //the new display name\n * }}\n * participantJoined - receives event notifications about new participant.\n * The listener will receive object with the following structure:\n * {{\n * jid: jid //the jid of the participant\n * }}\n * participantLeft - receives event notifications about participant the that\n * left the room.\n * The listener will receive object with the following structure:\n * {{\n * jid: jid //the jid of the participant\n * }}\n * video-conference-joined - receives event notifications fired when the local\n * user has joined the video conference.\n * The listener will receive object with the following structure:\n * {{\n * roomName: room //the room name of the conference\n * }}\n * video-conference-left - receives event notifications fired when the local\n * user has joined the video conference.\n * The listener will receive object with the following structure:\n * {{\n * roomName: room //the room name of the conference\n * }}\n * @param event the name of the event\n * @param listener the listener\n */\nJitsiMeetExternalAPI.prototype.addEventListener = function(event, listener) {\n    if(!(event in events)) {\n        logger.error(\"Not supported event name.\");\n        return;\n    }\n    // We cannot remove listeners from postis that's why we are handling the\n    // callback that way.\n    if(!(event in this.eventHandlers))\n        this.postis.listen(events[event], function(data) {\n            if((event in this.eventHandlers) &&\n                typeof this.eventHandlers[event] === \"function\")\n                this.eventHandlers[event].call(null, data);\n        }.bind(this));\n    this.eventHandlers[event] = listener;\n    changeEventStatus(this.postis, event, true);\n};\n\n/**\n * Removes event listener.\n * @param event the name of the event.\n */\nJitsiMeetExternalAPI.prototype.removeEventListener = function(event) {\n    if(!(event in this.eventHandlers))\n    {\n        logger.error(\"The event \" + event + \" is not registered.\");\n        return;\n    }\n    delete this.eventHandlers[event];\n    changeEventStatus(this.postis, event, false);\n};\n\n/**\n * Removes event listeners.\n * @param events array with the names of the events.\n */\nJitsiMeetExternalAPI.prototype.removeEventListeners = function(events) {\n    for(var i = 0; i < events.length; i++)\n        this.removeEventListener(events[i]);\n};\n\n/**\n * Removes the listeners and removes the Jitsi Meet frame.\n */\nJitsiMeetExternalAPI.prototype.dispose = function() {\n    this.postis.destroy();\n    var frame = document.getElementById(this.frameName);\n    if(frame)\n        frame.src = 'about:blank';\n    var self = this;\n    window.setTimeout(function () {\n        self.iframeHolder.removeChild(self.frame);\n        self.iframeHolder.parentNode.removeChild(self.iframeHolder);\n    }, 10);\n};\n\nmodule.exports = JitsiMeetExternalAPI;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/API/external/external_api.js","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Ordered log levels.\n */\nvar levels = {\n    \"trace\": 0,\n    \"debug\": 1,\n    \"info\": 2,\n    \"log\": 3,\n    \"warn\": 4,\n    \"error\": 5\n};\n\n/**\n * The default transport - console\n * @type LoggerTransport\n */\nLogger.consoleTransport = console;\n\n/**\n * The array which stores currently registered global transports.\n * @type {[LoggerTransport]}\n */\nvar globalTransports = [ Logger.consoleTransport ];\n\n/**\n * Adds given {@link LoggerTransport} instance to the list of global\n * transports which means that it'll be used by all {@link Logger}s\n * @param {LoggerTransport} transport\n */\nLogger.addGlobalTransport = function(transport) {\n    if (globalTransports.indexOf(transport) === -1) {\n        globalTransports.push(transport);\n    }\n};\n\n/**\n * Removes given {@link LoggerTransport} instance from the list of global\n * transports\n * @param {LoggerTransport} transport\n */\nLogger.removeGlobalTransport = function(transport) {\n    var transportIdx = globalTransports.indexOf(transport);\n    if (transportIdx !== -1) {\n        globalTransports.splice(transportIdx, 1);\n    }\n};\n\n/**\n * Parses Error's object stack trace and extracts information about the last\n * caller before the log method was called.\n * @returns JS object with info about the caller - method name, file location,\n * line and column.\n */\nfunction getCallerInfo() {\n    var callerInfo = {\n        methodName: \"\",\n        fileLocation: \"\",\n        line: null,\n        column: null\n    };\n    //gets the part of the stack without the logger wrappers\n    var error = new Error();\n    var stack = error.stack? error.stack.split(\"\\n\") : [];\n    if(!stack || stack.length < 1) {\n        return callerInfo;\n    }\n    var m = null;\n    if(stack[3]) {\n        m = stack[3].match(/\\s*at\\s*(.+?)\\s*\\((\\S*)\\s*:(\\d*)\\s*:(\\d*)\\)/);\n    }\n    if(!m || m.length <= 4) {\n        //Firefox && Safari\n        if(stack[2].indexOf(\"log@\") === 0){\n            //Safari\n            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf(\"@\"));\n        } else {\n            //Firefox\n            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf(\"@\"));\n        }\n        return callerInfo;\n    }\n\n    callerInfo.methodName = m[1];\n    callerInfo.fileLocation = m[2];\n    callerInfo.line = m[3];\n    callerInfo.column = m[4];\n    return callerInfo;\n}\n\n/**\n * Logs messages using the transports and level from the logger.\n * @param logger a logger instance.\n * @param level the log level of the message. See the levels variable.\n * @param arguments array with arguments that will be logged.\n */\nfunction log() {\n    var logger = arguments[0], level = arguments[1],\n        args = Array.prototype.slice.call(arguments, 2);\n    if(levels[level] < logger.level) {\n        return;\n    }\n\n    var callerInfo = getCallerInfo();\n    var transports = globalTransports.concat(logger.transports);\n    for(var i = 0; i < transports.length; i++) {\n        var t = transports[i];\n        var l = t[level];\n        if(l && typeof(l) === \"function\") {\n            l.bind(t, logger.id? \"[\" + logger.id + \"]\" : \"\", \"<\" + callerInfo.methodName + \">: \")\n                .apply(t, args);\n        }\n    }\n}\n\n/**\n *\n * Constructs new logger object.\n * @param level the logging level for the new logger\n * @param id optional identifier for the logger instance.\n * @param {LoggerTransport} transports optional list of handlers(objects) for\n * the logs. The handlers must support - log, warn, error, debug, info, trace.\n * @param format optional (NOT implemented) string.\n */\nfunction Logger(level, id, transports, format) {\n    this.id = id;\n    this.format = format;\n    this.transports = transports;\n    if(!this.transports) {\n        this.transports = [];\n    }\n    this.level = levels[level];\n    var methods = Object.keys(levels);\n    for(var i = 0; i < methods.length; i++){\n        this[methods[i]] =\n            log.bind(null, this, methods[i]);\n    }\n}\n\n/**\n * Sets the log level for the logger.\n * @param level the new log level.\n */\nLogger.prototype.setLevel = function (level) {\n    this.level = levels[level];\n};\nmodule.exports = Logger;\n\n/**\n * Enum for the supported log levels.\n */\nLogger.levels = {\n    TRACE: \"trace\",\n    DEBUG: \"debug\",\n    INFO: \"info\",\n    LOG: \"log\",\n    WARN: \"warn\",\n    ERROR: \"error\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/Logger.js\n// module id = 1\n// module chunks = 0","/* Copyright @ 2016 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Logger = require('./Logger.js');\n\n/**\n * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>\n * and thus can be added as global transport in order to capture all the logs.\n *\n * It captures subsequent log lines created whenever <tt>Logger</tt> logs\n * a message and stores them in a queue in order to batch log entries. There are\n * time and size limit constraints which determine how often batch entries are\n * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>\n * will use the <tt>logStorage</tt> object given as an argument to save\n * the batch log entry.\n *\n * @param {Object} logStorage an object which allows to store the logs collected\n * @param {function(string|object[])} logStorage.storeLogs a method called when\n * this <tt>LogCollector</tt> requests log entry storage. The method's argument\n * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given\n * item is an object it means that it's an aggregated message. That is a message\n * which is the same as the previous one and it's representation has\n * the following format:\n * {\n *   {string} text: 'the text of some duplicated message'\n *   {number} count: 3 // how many times the message appeared in a row\n * }\n * If a message \"B\" after an aggregated message \"A\" is different, then it breaks\n * the sequence of \"A\". Which means that even if the next message \"C\" is\n * the same as \"A\" it will start a new aggregated message \"C\".\n * @param {function()} logStorage.isReady a method which should return\n * a <tt>boolean</tt> to tell the collector that it's ready to store. During the\n * time storage is not ready log batches will be cached and stored on the next\n * occasion (flush or interval timeout).\n *\n * @param {Object} options the <tt>LogCollector</tt> configuration options.\n * @param {number} options.maxEntryLength the size limit for a single log entry\n * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it\n * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>\n * returns <tt>true</tt>. Otherwise the log entry will be cached until the log\n * storage becomes ready. Note that the \"is ready\" condition is checked every\n * <tt>options.storeInterval</tt> milliseconds.\n * @param {number} options.storeInterval how often the logs should be stored in\n * case <tt>maxEntryLength</tt> was not exceeded.\n * @param {boolean} options.stringifyObjects indicates whether or not object\n * arguments should be \"stringified\" with <tt>JSON.stringify</tt> when a log\n * message is composed. Note that objects logged on the error log level are\n * always stringified.\n *\n * @constructor\n */\nfunction LogCollector(logStorage, options) {\n    this.logStorage = logStorage;\n    this.stringifyObjects\n        = options && options.stringifyObjects\n            ? options.stringifyObjects : false;\n    this.storeInterval\n        = options && options.storeInterval\n            ? options.storeInterval: 30000;\n    this.maxEntryLength\n        = options && options.maxEntryLength\n            ? options.maxEntryLength : 10000;\n    // Bind the log method for each level to the corresponding method name\n    // in order to implement \"global log transport\" object.\n    Object.keys(Logger.levels).forEach(\n    function (logLevel) {\n        var methodName = Logger.levels[logLevel];\n        this[methodName] = function (logLevel) {\n            this._log.apply(this, arguments);\n        }.bind(this, logLevel);\n    }.bind(this));\n    /**\n     * The ID of store logs interval if one is currently scheduled or\n     * <tt>null</tt> otherwise.\n     * @type {number|null}\n     */\n    this.storeLogsIntervalID = null;\n    /**\n     * The log messages that are to be batched into log entry when\n     * {@link LogCollector._flush} method is called.\n     * @type {string[]}\n     */\n    this.queue = [];\n    /**\n     * The total length of all messages currently stored in the {@link queue}.\n     * @type {number}\n     */\n    this.totalLen = 0;\n    /**\n     * An array used to temporarily store log batches, before the storage gets\n     * ready.\n     * @type {string[]}\n     */\n    this.outputCache = [];\n}\n\n/**\n * Method called inside of {@link formatLogMessage} in order to covert an\n * <tt>Object</tt> argument to string. The conversion will happen when either\n * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}\n * log level. The default implementation uses <tt>JSON.stringify</tt> and\n * returns \"[object with circular refs?]\" instead of an object if it fails.\n *\n * @param {object} someObject the <tt>object</tt> to be stringified.\n *\n * @return {string} the result of <tt>JSON.stringify</tt> or\n * \"[object with circular refs?]\" if any error occurs during \"stringification\".\n *\n * @protected\n */\nLogCollector.prototype.stringify = function (someObject) {\n    try {\n        return JSON.stringify(someObject);\n    } catch (error) {\n        return \"[object with circular refs?]\";\n    }\n};\n\n/**\n * Formats log entry for the given logging level and arguments passed to the\n * <tt>Logger</tt>'s log method. The first argument is log level and the next\n * arguments have to be captured using JS built-in 'arguments' variable.\n *\n * @param {Logger.levels} logLevel provides the logging level of the message to\n * be logged.\n *\n * @return {string|null} a non-empty string representation of the log entry\n * crafted from the log arguments. If the return value is <tt>null</tt> then\n * the message wil be discarded by this <tt>LogCollector</tt>.\n *\n * @protected\n */\nLogCollector.prototype.formatLogMessage\n= function (logLevel/*, arg1, arg2, arg3... */) {\n    var msg = '';\n    for (var i = 1, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        // objects logged on error level are always converted to JSON\n        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR)\n            && typeof arg === 'object') {\n            arg = this.stringify(arg);\n        }\n        msg += arg;\n        if (i != len - 1) {\n            msg += ' ';\n        }\n    }\n    return msg.length ? msg : null;\n};\n\n/**\n * The log method bound to each of the logging levels in order to implement\n * \"global log transport\" object.\n *\n * @private\n */\nLogCollector.prototype._log = function() {\n\n    // var logLevel = arguments[0]; first argument is the log level\n    var msg = this.formatLogMessage.apply(this, arguments);\n    if (msg) {\n        // The same as the previous message aggregation logic\n        var prevMessage\n            = this.queue.length ? this.queue[this.queue.length -1] : undefined;\n        // NOTE that typeof undefined is 'undefined'\n        var prevMessageText\n            = typeof prevMessage === 'object' ? prevMessage.text : prevMessage;\n        // Is it the same as the previous one ?\n        if (prevMessageText == msg) {\n            if (typeof prevMessage === 'object') {\n                prevMessage.count += 1;\n            } else {\n                this.queue[this.queue.length-1] = {\n                    text: msg,\n                    count: 2\n                }\n            }\n        } else {\n            this.queue.push(msg);\n            this.totalLen += msg.length;\n        }\n    }\n\n    if (this.totalLen >= this.maxEntryLength) {\n        this._flush(true /* force */, true /* reschedule */);\n    }\n};\n\n/**\n * Starts periodical \"store logs\" task which will be triggered at the interval\n * specified in the constructor options.\n */\nLogCollector.prototype.start = function () {\n    this._reschedulePublishInterval();\n};\n\n/**\n * Reschedules the periodical \"store logs\" task which will store the next batch\n * log entry in the storage.\n * @private\n */\nLogCollector.prototype._reschedulePublishInterval = function () {\n    if (this.storeLogsIntervalID) {\n        window.clearTimeout(this.storeLogsIntervalID);\n        this.storeLogsIntervalID = null;\n    }\n    // It's actually a timeout, because it is rescheduled on every flush\n    this.storeLogsIntervalID\n        = window.setTimeout(\n            this._flush.bind(\n                this, false /* do not force */, true /* reschedule */),\n            this.storeInterval);\n};\n\n/**\n * Call this method to flush the log entry buffer and store it in the log\n * storage immediately (given that the storage is ready).\n */\nLogCollector.prototype.flush = function() {\n    this._flush(\n        false /* do not force, as it will not be stored anyway */,\n        true /* reschedule next update */ )\n};\n\n/**\n * Stores the next batch log entry in the log storage.\n * @param {boolean} force enforce current logs batch to be stored or cached if\n * there is anything to be logged, but the storage is not ready yet. One of\n * legitimate reasons to force is when the logs length exceeds size limit which\n * could result in truncation.\n * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be\n * scheduled after the log entry is stored. <tt>false</tt> will end the periodic\n * task cycle.\n * @private\n */\nLogCollector.prototype._flush = function(force, reschedule) {\n    // Publish only if there's anything to be logged\n    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {\n        //FIXME avoid truncating\n        // right now we don't care if the message size is \"slightly\" exceeded\n        if (this.logStorage.isReady()) {\n            // Sends all cached logs\n            if (this.outputCache.length) {\n                this.outputCache.forEach(\n                    function (cachedQueue) {\n                        this.logStorage.storeLogs(cachedQueue);\n                    }.bind(this)\n                );\n                // Clear the cache\n                this.outputCache = [];\n            }\n            // Send current batch\n            this.logStorage.storeLogs(this.queue);\n        } else {\n            this.outputCache.push(this.queue);\n        }\n\n        this.queue = [];\n        this.totalLen = 0;\n    }\n\n    if (reschedule) {\n        this._reschedulePublishInterval();\n    }\n};\n\n/**\n * Stops the periodical \"store logs\" task and immediately stores any pending\n * log entries as a batch.\n */\nLogCollector.prototype.stop = function() {\n    // Flush and stop publishing logs\n    this._flush(false /* do not force */, false /* do not reschedule */);\n};\n\nmodule.exports = LogCollector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/LogCollector.js\n// module id = 2\n// module chunks = 0","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Logger = require(\"./Logger\");\nvar LogCollector = require(\"./LogCollector\");\n\n/**\n * Definition of the log method\n * @name log_method\n * @function\n * @param {...*} log_args the arguments to be logged\n */\n/**\n * The logger's transport type definition.\n *\n * @typedef {object} LoggerTransport\n *\n * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level\n * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level\n * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level\n * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level\n * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level\n * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level\n */\n\n/**\n * Map with the created loggers with ID.\n */\nvar idLoggers = {};\n\n/**\n * Array with the loggers without id.\n */\nvar loggers = [];\n\n/**\n * Log level for the lbrary.\n */\nvar curLevel = Logger.levels.TRACE;\n\n\nmodule.exports = {\n    /**\n     * Adds given {@link LoggerTransport} instance to the list of global\n     * transports which means that it'll be used by all {@link Logger}s\n     * @param {LoggerTransport} transport\n     */\n    addGlobalTransport: function(transport) {\n        Logger.addGlobalTransport(transport);\n    },\n    /**\n     * Removes given {@link LoggerTransport} instance from the list of global\n     * transports\n     * @param {LoggerTransport} transport\n     */\n    removeGlobalTransport: function(transport) {\n        Logger.removeGlobalTransport(transport);\n    },\n    /**\n     * Creates new logger.\n     * @arguments the same as Logger constructor\n     */\n    getLogger: function(id, transports, format) {\n        var logger = new Logger(curLevel, id, transports, format);\n        if(id) {\n            idLoggers[id] = idLoggers[id] || [];\n            idLoggers[id].push(logger);\n        } else {\n            loggers.push(logger);\n        }\n        return logger;\n    },\n    /**\n     * Changes the log level for the existing loggers by id.\n     * @param level the new log level.\n     * @param id if specified the level will be changed only for loggers with the\n     * same id. Otherwise the operation will affect all loggers that don't\n     * have id.\n     */\n    setLogLevelById: function(level, id) {\n        var l = id? (idLoggers[id] || []) : loggers;\n        for(var i = 0; i < l.length; i++) {\n            l[i].setLevel(level);\n        }\n    },\n    /**\n     * Changes the log level for all existing loggers.\n     * @param level the new log level.\n     */\n    setLogLevel: function (level) {\n        curLevel = level;\n        var i = 0;\n        for(; i < loggers.length; i++) {\n            loggers[i].setLevel(level);\n        }\n\n        for(var id in idLoggers) {\n            var l = idLoggers[id] || [];\n            for(i = 0; i < l.length; i++) {\n                l[i].setLevel(level);\n            }\n        }\n    },\n    /**\n     * The supported log levels.\n     */\n    levels: Logger.levels,\n    /**\n     * Exports the <tt>LogCollector</tt>.\n     */\n    LogCollector: LogCollector\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/index.js\n// module id = 3\n// module chunks = 0","function Postis(options) {\n  var scope = options.scope;\n  var targetWindow = options.window;\n  var windowForEventListening = options.windowForEventListening || window;\n  var listeners = {};\n  var sendBuffer = [];\n  var listenBuffer = {};\n  var ready = false;\n  var readyMethod = \"__ready__\";\n  var readynessCheck;\n\n  var listener = function(event) {\n    var data;\n    try {\n      data = JSON.parse(event.data);\n    } catch (e) {\n      return;\n    }\n\n    if (data.postis && data.scope === scope) {\n      var listenersForMethod = listeners[data.method];\n      if (listenersForMethod) {\n        for (var i = 0; i < listenersForMethod.length; i++) {\n          listenersForMethod[i].call(null, data.params);\n        }\n      } else {\n        listenBuffer[data.method] = listenBuffer[data.method] || [];\n        listenBuffer[data.method].push(data.params);\n      }\n    }\n  };\n\n  windowForEventListening.addEventListener(\"message\", listener, false);\n\n  var postis = {\n    listen: function (method, callback) {\n      listeners[method] = listeners[method] || [];\n      listeners[method].push(callback);\n\n      var listenBufferForMethod = listenBuffer[method];\n      if (listenBufferForMethod) {\n        var listenersForMethod = listeners[method];\n        for (var i = 0; i < listenersForMethod.length; i++) {\n          for (var j = 0; j < listenBufferForMethod.length; j++) {\n            listenersForMethod[i].call(null, listenBufferForMethod[j]);\n          }\n        }\n      }\n      delete listenBuffer[method];\n    },\n\n    send: function (opts) {\n      var method = opts.method;\n\n      if ((ready || opts.method === readyMethod) && (targetWindow && typeof targetWindow.postMessage === \"function\")) {\n        targetWindow.postMessage(JSON.stringify({\n          postis: true,\n          scope: scope,\n          method: method,\n          params: opts.params\n        }), \"*\");\n      } else {\n        sendBuffer.push(opts);\n      }\n    },\n\n    ready: function (callback) {\n      if (ready) {\n        callback();\n      } else {\n        setTimeout(function () { postis.ready(callback); }, 50);\n      }\n    },\n\n    destroy: function (callback) {\n      clearInterval(readynessCheck);\n      ready = false;\n      if (windowForEventListening && typeof windowForEventListening.removeEventListener === \"function\") {\n        windowForEventListening.removeEventListener(\"message\", listener);\n      }\n      callback && callback();\n    }\n  };\n\n  var readyCheckID = +new Date() + Math.random() + \"\";\n\n  readynessCheck = setInterval(function () {\n    postis.send({\n      method: readyMethod,\n      params: readyCheckID\n    });\n  }, 50);\n\n  postis.listen(readyMethod, function (id) {\n    if (id === readyCheckID) {\n      clearInterval(readynessCheck);\n      ready = true;\n\n      for (var i = 0; i < sendBuffer.length; i++) {\n        postis.send(sendBuffer[i]);\n      }\n      sendBuffer = [];\n    } else {\n      postis.send({\n        method: readyMethod,\n        params: id\n      });\n    }\n  });\n\n  return postis;\n}\n\nmodule.exports = Postis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/postis/src/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}